# 12.11.2 Скрипт отслеживания головы

Скрипт head\_tracker.py довольно длинный, но простой. Общий процесс заключается в следующем:

* Инициализации сервоприводов.
* Подписка на топик /roi.
* Если /roi удаляется от центра обзора, подайте команду сервоприводам на перемещение камеры в направлении ее повторного центрирования.
* Если /roi теряется в течение заданного периода времени, повторно центрируйте сервоприводы, чтобы защитить их от перегрева.



Для отслеживания цели скрипт использует своего рода"отслеживание скорости". Если вы переместите камеру в то место, где сейчас находится отслеживаемый объект, он может переместиться к тому времени, когда камера доберется туда. Вы можете подумать, что можете просто обновить целевую позицию камеры с высокой скоростью и, следовательно, не отставать от объекта. Однако этот вид отслеживания положения приведет к отрывистому стаккато-подобному движению камеры. Оптимальная стратегия заключается в том, чтобы всегда направлять камеру вперед цели, но регулировать скорость сервопривода так, чтобы она была пропорциональна смещению цели от центра обзора. Это приводит к гораздо более плавному движению камеры и гарантирует, что она движется быстро, если цель находится далеко от центра, и медленнее, если смещение невелико. Когда цель центрирована, скорость сервопривода будет равна нулю, и поэтому камера не будет двигаться.

Скрипт head\_tracker.py немного длинноват для отображения в полном объеме, поэтому давайте рассмотрим только ключевые разделы кода. Вы можете просмотреть весь исходный файл по следующей ссылке:

Ссылка на источник: [head\_tracker.py](https://github.com/pirobot/rbx1/blob/indigo-devel/rbx1_dynamixels/nodes/head_tracker.py)

Вот теперь ключевые строки.

```python
 rate = rospy.get_param("~rate", 10)
 r = rospy.Rate(rate)
 tick = 1.0 / rate

# Держите скорость обновления ниже - примерно 10 Гц; 
# в противном случае сервоприводы могут вести себя хаотично.
 speed_update_rate = rospy.get_param("~speed_update_rate", 10)
 speed_update_interval = 1.0 / speed_update_rate

# Насколько большие изменения нам нужны в скорости, прежде 
# чем мы отправим обновление к сервомоторам?
 self.speed_update_threshold = rospy.get_param("~speed_update_threshold", 0.01)
```

Мы определяем два параметра скорости в верхней части скрипта. Общий параметр скорости управляет тем, как быстро мы обновляем контур слежения, который включает в себя изменение как скорости, так и угла соединения сервоприводов в зависимости от местоположения цели. Параметр speed\_update\_interval обычно устанавливается ниже и определяет, как часто мы обновляем скорости сервоприводов. Единственная причина для этого заключается в том, что оказывается, что сервоприводы Dynamixel могут действовать немного хаотично, если мы слишком часто пытаемся регулировать их скорость. Частота обновления менее 10 Гц или около того, по-видимому, приводит к лучшему поведению. Мы также устанавливаем speed\_update\_threshold так, чтобы мы обновляли скорость сервопривода только в том случае, если вновь вычисленная скорость отличается на столько же от предыдущей скорости.

```python
self.head_pan_joint = rospy.get_param('~head_pan_joint', 'head_pan_joint')
self.head_tilt_joint = rospy.get_param('~head_tilt_joint', 'head_tilt_joint')
self.joints = [self.head_pan_joint, self.head_tilt_joint]
```

Нам нужно знать название шарниров поворота и наклона в модели URDF робота. Если ваши имена шарниров отличаются от значений по умолчанию, используйте эти два параметра в файле head\_tracker.launch, чтобы установить их соответствующим образом.

```python
# Скорости шарниров задаются в радианах в секунду
 self.default_joint_speed = rospy.get_param('~default_joint_speed', 0.3)
 self.max_joint_speed = rospy.get_param('~max_joint_speed', 0.5)
# На какое расстояние впереди или позади цели (в радианах) мы должны стремиться?
 self.lead_target_angle = rospy.get_param('~lead_target_angle', 1.0)

# Пороги панорамирования/наклона указывают, какой процент окна изображения 
# ROI должен быть смещен от центра, прежде чем мы сделаем движение
self.pan_threshold = rospy.get_param('~pan_threshold', 0.025)
self.tilt_threshold = rospy.get_param('~tilt_threshold', 0.025)
# Параметр gain_pan и gain_tilt определяют, насколько чувствительны 
# движения сервопривода. Если они установлены слишком высоко, 
# это может привести к колебаниям.
self.gain_pan = rospy.get_param('~gain_pan', 1.0)
self.gain_tilt = rospy.get_param('~gain_tilt', 1.0)
# Установите ограничения на углы панорамирования и наклона
self.max_pan = rospy.get_param('~max_pan', radians(145))
self.min_pan = rospy.get_param('~min_pan', radians(-145))
self.max_tilt = rospy.get_param('~max_tilt', radians(90))
self.min_tilt = rospy.get_param('~min_tilt', radians(-90))
```

Далее следует список параметров для управления поведением отслеживания. Большинство параметров легко понять из добавленных комментариев. Параметры gain\_pan и gain\_tilt определяют, как быстро сервоприводы будут реагировать на смещение цели из поля зрения камеры. Если они установлены слишком высоко, то возникнут колебания. Если они установлены слишком низко, то движение камеры будет отставать от движущейся цели.

```python
 self.recenter_timeout = rospy.get_param('~recenter_timeout', 5)
```

Параметр recenter\_timeout определяет, как долго \(в секундах\) цель может быть потеряна, прежде чем мы отцентрируем сервоприводы. Когда цель исчезает из поля зрения, то скрипт head\_tracker.py останавливает сервоприводы так, чтобы они удерживали камеру в последнем положении, которое у них было до того, как цель была потеряна. Однако это может привести к перегреву сервоприводов, если камера будет удерживаться таким образом слишком долго. Повторное центрирование сервоприводов позволяет им вернуться в нейтральное положение и остыть.

```python
# Получим блокировку для обновления self.move_cmd значений
 self.lock = thread.allocate_lock()
```

Здесь мы создаем объект блокировки потока и назначаем его переменной self.lock. Нам понадобится эта блокировка, чтобы сделать нашу общую программу потокобезопасной, так как мы будем обновлять позиции шарниров и скорости в двух местах: основной текст скрипта и функция обратного вызова \(определенная ниже\), назначенная топику /roi. Поскольку ROS запускает отдельный поток для каждого обратного вызова подписчика, нам нужно защитить наши обновления шарниров с помощью блокировки, как мы покажем далее.

```python
 self.init_servos()
```

Инициализация сервоприводов находится в функции init\_servos \(\), которая выглядит следующим образом.

```python
def init_servos(self):
 # Создаем словари для хранения контроллеров скорости, положения и крутящего момента
 self.servo_speed = dict()
 self.servo_position = dict()
 self.torque_enable = dict()
```

Сначала мы определяем три словаря Python для хранения сервоконтроллеров скорости, положения и крутящего момента.

```python
for joint in sorted(self.joints):
```

Затем мы проходим через все шарниры, перечисленные в параметра self.joints. В нашем случае есть только два сервопривода с именами head\_pan\_joint и head\_tilt\_joint.

```python
 set_speed_service = '/' + joint + '/set_speed'
 rospy.wait_for_service(set_speed_service)
 self.servo_speed[joint] = rospy.ServiceProxy(set_speed_service,
SetSpeed, persistent=True)
```

Напомним, что пакет dynamixel\_controller использует службу set\_speed для каждого сервопривода, чтобы установить их скорость. Поэтому мы подключаемся к службе set\_speed для каждого сервоконтроллера. Использование аргумента persistent=True в операторе Service Proxy очень важно. В противном случае rospy придется заново подключаться к службе set\_speed каждый раз, когда мы хотим отрегулировать скорость сервомотора. Поскольку мы будем постоянно обновлять скорость сервопривода во время отслеживания, мы хотим избежать этой задержки соединения.

```python
self.servo_speed[name](self.default_joint_speed)
```

