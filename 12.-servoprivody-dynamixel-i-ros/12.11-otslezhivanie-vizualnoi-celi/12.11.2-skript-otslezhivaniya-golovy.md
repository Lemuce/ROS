# 12.11.2 Скрипт отслеживания головы

Скрипт head\_tracker.py довольно длинный, но простой. Общий процесс заключается в следующем:

* Инициализации сервоприводов.
* Подписка на топик /roi.
* Если /roi удаляется от центра обзора, подайте команду сервоприводам на перемещение камеры в направлении ее повторного центрирования.
* Если /roi теряется в течение заданного периода времени, повторно центрируйте сервоприводы, чтобы защитить их от перегрева.



Для отслеживания цели скрипт использует своего рода"отслеживание скорости". Если вы переместите камеру в то место, где сейчас находится отслеживаемый объект, он может переместиться к тому времени, когда камера доберется туда. Вы можете подумать, что можете просто обновить целевую позицию камеры с высокой скоростью и, следовательно, не отставать от объекта. Однако этот вид отслеживания положения приведет к отрывистому стаккато-подобному движению камеры. Оптимальная стратегия заключается в том, чтобы всегда направлять камеру вперед цели, но регулировать скорость сервопривода так, чтобы она была пропорциональна смещению цели от центра обзора. Это приводит к гораздо более плавному движению камеры и гарантирует, что она движется быстро, если цель находится далеко от центра, и медленнее, если смещение невелико. Когда цель центрирована, скорость сервопривода будет равна нулю, и поэтому камера не будет двигаться.

Скрипт head\_tracker.py немного длинноват для отображения в полном объеме, поэтому давайте рассмотрим только ключевые разделы кода. Вы можете просмотреть весь исходный файл по следующей ссылке:

Ссылка на источник: [head\_tracker.py](https://github.com/pirobot/rbx1/blob/indigo-devel/rbx1_dynamixels/nodes/head_tracker.py)

Вот теперь ключевые строки.

```text
 rate = rospy.get_param("~rate", 10)
 r = rospy.Rate(rate)
 tick = 1.0 / rate

# Держите скорость обновления ниже - примерно 10 Гц; 
# в противном случае сервоприводы могут вести себя хаотично.
 speed_update_rate = rospy.get_param("~speed_update_rate", 10)
 speed_update_interval = 1.0 / speed_update_rate

# Насколько большие изменения нам нужны в скорости, прежде 
# чем мы отправим обновление к сервомоторам?
 self.speed_update_threshold = rospy.get_param("~speed_update_threshold", 0.01)
```

Мы определяем два параметра скорости в верхней части скрипта. Общий параметр скорости управляет тем, как быстро мы обновляем контур слежения, который включает в себя изменение как скорости, так и угла соединения сервоприводов в зависимости от местоположения цели. Параметр speed\_update\_interval обычно устанавливается ниже и определяет, как часто мы обновляем скорости сервоприводов. Единственная причина для этого заключается в том, что оказывается, что сервоприводы Dynamixel могут действовать немного хаотично, если мы слишком часто пытаемся регулировать их скорость. Частота обновления менее 10 Гц или около того, по-видимому, приводит к лучшему поведению. Мы также устанавливаем speed\_update\_threshold так, чтобы мы обновляли скорость сервопривода только в том случае, если вновь вычисленная скорость отличается на столько же от предыдущей скорости.

```text
self.head_pan_joint = rospy.get_param('~head_pan_joint', 'head_pan_joint')
self.head_tilt_joint = rospy.get_param('~head_tilt_joint', 'head_tilt_joint')
self.joints = [self.head_pan_joint, self.head_tilt_joint]
```

Нам нужно знать название шарниров поворота и наклона в модели URDF робота. Если ваши имена шарниров отличаются от значений по умолчанию, используйте эти два параметра в файле head\_tracker.launch, чтобы установить их соответствующим образом.

```text
# Скорости шарниров задаются в радианах в секунду
 self.default_joint_speed = rospy.get_param('~default_joint_speed', 0.3)
 self.max_joint_speed = rospy.get_param('~max_joint_speed', 0.5)
# На какое расстояние впереди или позади цели (в радианах) мы должны стремиться?
 self.lead_target_angle = rospy.get_param('~lead_target_angle', 1.0)

# Пороги панорамирования/наклона указывают, какой процент окна изображения 
# ROI должен быть смещен от центра, прежде чем мы сделаем движение
self.pan_threshold = rospy.get_param('~pan_threshold', 0.025)
self.tilt_threshold = rospy.get_param('~tilt_threshold', 0.025)
# Параметр gain_pan и gain_tilt определяют, насколько чувствительны 
# движения сервопривода. Если они установлены слишком высоко, 
# это может привести к колебаниям.
self.gain_pan = rospy.get_param('~gain_pan', 1.0)
self.gain_tilt = rospy.get_param('~gain_tilt', 1.0)
# Установите ограничения на углы панорамирования и наклона
self.max_pan = rospy.get_param('~max_pan', radians(145))
self.min_pan = rospy.get_param('~min_pan', radians(-145))
self.max_tilt = rospy.get_param('~max_tilt', radians(90))
self.min_tilt = rospy.get_param('~min_tilt', radians(-90))
```

